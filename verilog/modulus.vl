module x_100_mod_47(X, S);

input [100:1] X;
output [6:1] S;
wire [14:1] S_temp_1;
wire [11:1] S_temp_2;
wire [9:1] S_temp_3;
wire [8:1] S_temp_4;
wire [7:1] S_temp_5;
reg [6:1] S_temp;
reg [6:1] S_final;

assign S_temp_1 = X[6:1] + X[12:7]*5'b10001 +
					X[18:13]*3'b111 + X[24:19]*5'b11001 +
					X[30:25]*2'b10 + X[36:31]*6'b100010 +
					X[42:37]*4'b1110 + X[48:43]*2'b11 +
					X[54:49]*3'b100 + X[60:55]*5'b10101 +
					X[66:61]*5'b11100 + X[72:67]*3'b110 +
					X[78:73]*4'b1000 + X[84:79]*6'b101010 +
					X[90:85]*4'b1001 + X[96:91]*4'b1100 +
					X[100:97]*5'b10000; 
					
assign S_temp_2 = S_temp_1[6:1] +
					S_temp_1[12:7]*5'b10001 +
					S_temp_1[14:13]*3'b111;
					
assign S_temp_3 = S_temp_2[6:1] + S_temp_2[11:7]*5'b10001;

assign S_temp_4 = S_temp_3[6:1] + S_temp_3[9:7]*5'b10001;

assign S_temp_5 = S_temp_4[6:1] + S_temp_4[8:7]*5'b10001;

always @(S_temp_5)
begin 
	if (S_temp_5 >= 6'b101111)
		S_temp <= S_temp_5 - 6'b101111;
	else
		S_temp <= S_temp_5;
end

assign S = S_temp;

endmodule

module testbench;
  reg [100:1] X;
  wire [6:1] S;

  x_100_mod_47 dut (
    .X(X),
    .S(S)
  );

  initial begin
    X = 120; // Przykładowa wartość X
    #10000; // Symulacja zostanie zatrzymana po 10000 jednostkach czasu
    $display("S = %d", S);
    $finish;
  end
endmodule
